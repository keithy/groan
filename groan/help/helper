#!/bin/bash

#Provide some basic features and
#Redirect groan <cmd> to groan.<cmd>.cmd.sh

#constants
configLocationsFileName="config-locations.source"

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob # make sure globs are empty arrays if nothing is foound

# our contribution to help
commonOptions="common options:
--help    | -h | -?  Usage help for a command
--quiet   | -q       Quiet mode - say nothing
--verbose | -V       Verbose
--debug   | -d | -D  Debug - tell all
--dry-run            # default
--confirm            # not a dry run - perform action"

#default flags
DEBUG=false
VERBOSE=false
LOUD=true
DRYRUN=true
CONFIRM=false
SHOWHELP=false #exec command and only display the help metadata
METADATAONLY=false #exec command only as far as the help metadata

#Options processing - search through the arguments for the command and flags
args=()
command=""
for arg in "$@"
do
	case "$arg" in
	  --debug | -d | -D)
	    	DEBUG=true
	    	VERBOSE=true
	    	LOUD=true
	    ;;
	  --help | -h | "-?")
	  		SHOWHELP=true
	  		METADATAONLY=true
	    ;;
	  --verbose | --v | -v | -V )
	    	DEBUG=false
	    	VERBOSE=true
	    	LOUD=true
	   ;;
	   --quiet | -q)
	    	LOUD=false
	    	DEBUG=false
	    	VERBOSE=false
	    ;;
	    --dry-run | -dry | --dry)
	    	DRYRUN=true
	    	CONFIRM=false
	    ;;
	    --confirm)
	    	DRYRUN=false
	    	CONFIRM=true
	    ;;
	    *)
		if [[ "$command" = "" ]]; then
		   command=$arg
		else
		   args+=($arg)
		fi
	    ;;
	esac
	shift
done
arg_str="${args[@]:+${args[@]}}" # needed bash<=4.1 when set -u is on

#find platform
MACOSX=false
WINDOWS=false
UNIX=false
system=$(uname)

if [[  -d "/System/Library/Frameworks" ]] ; then
	MACOSX=true
elif [ -d "/WINDOWS" ] ; then
	WINDOWS=true
else
	UNIX=true
fi

#Define functions
function readLocations
{
 	configDir="$1"
 	
	$DEBUG && echo "Reading Locations: $configDir/$configLocationsFileName"
	source "$configDir/$configLocationsFileName"

	return 0
}

function readConfig
{
	for configFile in ${configFileLocations[@]}
	do
		$DEBUG && echo "Looked for config in: $configFile"
		if [[ -f $configFile ]]; then
			$VERBOSE && echo "Reading configuration: $configFile"
			source "$configFile"
			break
		fi
	done
}

# Passing In: $found $arg_str
function executeScript {
    case ${found##*.} in
        sh)
            $DEBUG && echo "Running source: $found $arg_str"
            source "$found" "${args[@]:+${args[@]}}"
            exit 0
        ;;
        exec)
            $DEBUG && echo "Running exec: $found $arg_str"
            exec "$found" "${args[@]:+${args[@]}}"
            exit 0
        ;;
        *)
            $DEBUG && echo "Extracting metadata from: $found"
            $DEBUG && sed -n 's|^#m# \(.*\)$|\1|p' "$found"

            #evaluate meta-data first
            eval "$(sed -n 's|^#m# \(.*\)$|\1|p' $found)"

            $DEBUG && echo "Running eval: $found $arg_str"				
            eval "$found" "${args[@]:+${args[@]}}"
            exit 0
        ;;
    esac
}

function checkMarkdownViewer {
    # Check for Markdown Viewer
    [[ -z $(which ${markdownViewerUtility%% *}) ]] && markdownViewerUtility="cat"
    $DEBUG && echo "Markdown viewer: $markdownViewerUtility"
}

# This function should be easy but bash begs to differ: ${args[@]:1}
function shiftArgsIntoCommand {
	command=""
	params=()

	if [[ ${#args[@]} > 0 ]]; then
		for arg in "${args[@]}"
		do 
			if [ -z "$command" ]; then
				command="$arg"
			else
				params+=("$arg")
			fi  
		done
	fi
	args=("${params[@]:+${params[@]}}")
}

function commandOrientation {

	thisScriptName="${1##*/}"
	thisScriptDir="${1%/*}"
	thisSubcommand="${thisScriptName%%.*}"

	breadcrumbs+=($thisSubcommand)
	breadcrumbsStr=${breadcrumbs[*]// /|}
}

D_INDENT=""
function commandOrientationDebug {
	echo "$D_INDENT workingDir: $workingDir" 		
	echo "$D_INDENT thisScriptName: $thisScriptName"
	echo "$D_INDENT thisScriptDir: $thisScriptDir"
	echo "$D_INDENT parentDir: ${parentDir:-}"
	echo "$D_INDENT parentCommand: '${parentCommand:-}' Args(${#args[@]}): ${args[@]:+${args[@]}}"
	echo "$D_INDENT thisSubcommand: '$thisSubcommand' Args(${#args[@]}): ${args[@]:+${args[@]}}"
	echo "$D_INDENT breadcrumbsStr: $breadcrumbsStr"
	D_INDENT+="  "
}

#find the $commandFile and importantly the $commandDir
commandFile="$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")"
if [ -L "$commandFile" ]; then
	scriptFile=`readlink -n $commandFile`
fi

workingDir=$(pwd)
commandName=${commandFile##*/} # `basename $scriptFile` 
breadcrumbs=("$commandName")
breadcrumbsStr=${breadcrumbs[*]// /|}
commandDir=${commandFile%/*} # `dirname $commandFile`
searchablePath=":$PATH:"

if $DEBUG; then
    echo "workingDir: $workingDir" 		
	echo "commandFile: $commandFile"
	echo "commandName: $commandName"
	echo "commandDir: $commandDir"
    echo "Subcommand requested: '$command'"
fi

# handle the default empty case

# no sub-command provided default to subcommmand help --help
if [[ "$command" = "" ]]; then
	command="help"
	SHOWHELP=true
	METADATAONLY=true
fi

readLocations $commandDir && readConfig

for loc in ${locations[@]} 
do
	source $loc/$defaultDispatch
done

$LOUD && echo "Warning: $thisScriptName $command : command  not found"
exit 1

# "This Code is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . 
# Any additional contribution submitted for incorporation into or for distribution with this file shall be presumed
# subject to the same license."

