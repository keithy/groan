#!/bin/bash

# The groan framework is implemented by a minimal set of scripts.
# All top-level "commands" are exactly the same code but with differing names.
# i.e. `rename-to-your-command-name` and `groan\groan` are identical.
#
# This "Command" script - Provides basic features and redirects `groan <cmd>` to `<cmd>.sub.sh`

# STRICT-MODE

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob # make sure globs are empty arrays if nothing is found
set -o allexport

# FUNCTIONS

function identifyPlatform
{
    MACOSX=false
    WINDOWS=false
    UNIX=false

    system=$(uname)
    if [[  -d "/System/Library/Frameworks" ]] ; then
        MACOSX=true
    elif [ -d "/WINDOWS" ] ; then
        WINDOWS=true
    else
        UNIX=true
    fi
}

function readLocations
{
  
    #commandDir commandName globals used within <name>.locations.sh file
    $DEBUG && echo "Reading Locations: ${commandDir}/${commandName}.locations.sh"
    source "${commandDir}/${commandName}.locations.sh"

    return 0
}

function readConfig
{
    for configFile in ${configFileLocations[@]}
    do
        $DEBUG && echo "Looked for config in: $configFile"
        if [[ -f "$configFile" ]]; then
                $VERBOSE && echo "Reading configuration: $configFile"
                source "$configFile"
                break
        fi
    done
}

function readThemes
{
    for themeFile in ${themePath[@]}
    do
        if [[ -f "$themeFile" ]]
        then
            $DEBUG && echo "Reading theme script: $themeFile"
            source "$themeFile"
        else
            $DEBUG && echo "Theme script not found: $themeFile"
        fi
    done
    return 0
}

# Args: "${args[@]:+${args[@]}}" # pattern needed when set -u is on bash<=4.1
 
function executeScript {

    scriptPath="$1"
    scriptDir="$2"
    scriptName="$3"
    scriptSubcommand="$4"
    breadcrumbs="${breadcrumbs} $scriptSubcommand"

    case ${scriptPath##*.} in
        sh)
            $DEBUG && echo "Running source: $scriptPath ${args[@]:+${args[@]}}"
            sourceScript "${args[@]:+${args[@]}}"
            exit 0
        ;;
        exec)
            $DEBUG && echo "Running exec: $scriptPath ${args[@]:+${args[@]}}"
            exec "$scriptPath" "${args[@]:+${args[@]}}"
            exit 0
        ;;
        *)
            $DEBUG && echo "Running metadata file: ${scriptPath/.sub.*/.meta.sh}"
            source "${scriptPath/.sub.*/.meta.sh}" ${args[@]:+${args[@]}}

            $SHOWHELP && executeHelp
            $METADATAONLY && return

            $DEBUG && echo "Running eval: $scriptPath ${args[@]:+${args[@]}}"				
            eval "$scriptPath" ${args[@]:+${args[@]}}
            exit 0
        ;;
    esac
}

function sourceScript
{
    source "$scriptPath"
}

function executeHelp {
   printf "${bold}${breadcrumbs}${reset} - $description\n\n$usage\n"
}

function checkMarkdownViewer {
    # Check for Markdown Viewer
    [[ -z $(which ${markdownViewerUtility%% *}) ]] && markdownViewerUtility="cat"
    $DEBUG && echo "Markdown viewer: $markdownViewerUtility"
}

# This function should be easy but bash begs to differ: ${args[@]:1}
function shiftArgsIntoNext {
    next=""
    params=()

    if [[ ${#args[@]} > 0 ]]; then
            for arg in "${args[@]}"
            do 
                    if [ -z "$next" ]; then
                            next="$arg"
                    else
                            params+=("$arg")
                    fi  
            done
    fi
    args=("${params[@]:+${params[@]}}")
}


D_INDENT=""
function subcommandOrientationDebug {

    echo "$D_INDENT workingDir: $workingDir" 		
    echo "$D_INDENT thisScriptName: ${bold}$thisScriptName${reset}"
    echo "$D_INDENT thisScriptDir: $thisScriptDir"
    echo "$D_INDENT parentDir: ${parentDir:-}"
    echo "$D_INDENT parentCommand: '${parentCommand:-}' Args(${#args[@]}): ${args[@]:+${args[@]}}"
    echo "$D_INDENT thisSubcommand: '$thisSubcommand' Args(${#args[@]}): ${args[@]:+${args[@]}}"
    echo "$D_INDENT breadcrumbs: ${breadcrumbs}"
    D_INDENT+="  "
}

# START

workingDir=$(pwd)

#find the $commandFile and importantly the $commandDir
commandFile="$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")"
if [ -L "$commandFile" ]; then
  commandFile=`readlink -n $commandFile`
fi
commandName=${commandFile##*/} # `basename $commandFile` 
rootCommandName="$commandName"

# our contribution to help

commonOptions="common options:
--help    | -h | -?  Usage help for a command
--quiet   | -q       Quiet mode - say nothing
--verbose | -V       Verbose
--debug   | -d | -D  Debug - tell all
--dry-run            # default
--confirm            # not a dry run - perform action
--theme=light        # select an alternate colour theme"

#default flags

DEBUG=false
VERBOSE=false
LOUD=true
DRYRUN=true
CONFIRM=false
SHOWHELP=false     #exec command and only display the help metadata
METADATAONLY=false #exec command only as far as the help metadata
THEME=default

# Options processing pattern - search through the arguments for the command and flags

args=()
subcommand=""
for arg in "$@"
do
    case "$arg" in
      --debug | -d | -D)
            DEBUG=true
            VERBOSE=true
            LOUD=true
      ;;
      --help | -h | "-?")
            SHOWHELP=true
            METADATAONLY=true
      ;;
      --verbose | --v | -v | -V )
            DEBUG=false
            VERBOSE=true
            LOUD=true
       ;;
      --quiet | -q)
            LOUD=false
            DEBUG=false
            VERBOSE=false
      ;;
      --dry-run | -dry | --dry)
            DRYRUN=true
            CONFIRM=false
      ;;
      --confirm)
            DRYRUN=false
            CONFIRM=true
      ;;
      --theme=*)
            THEME=${arg##--theme=}
      ;;
      -*)
          args+=($arg)
      ;;
      *)
          if [[ "$subcommand" = "" ]]; then
             subcommand=$arg
          else
             args+=($arg)
          fi
      ;;
    esac
    shift
done
 
breadcrumbs="$commandName"
rootCommandDir=$(dirname "$commandFile")
commandDir="$rootCommandDir"

readLocations
readConfig
readThemes

$VERBOSE && echo "${bold}SCRIPT${reset}: $workingDir${dim}/${reset}${bold}$commandName${reset}"
 
# handle the default empty case
[ -z "$subcommand" ] && subcommand="$defaultSubcommand"

if $DEBUG; then
    echo "Sub-command: '$subcommand'"
fi

for scriptDir in ${locations[@]} 
do
    source "$scriptDir/$defaultDispatch"
done

$LOUD && echo "Not Found: $commandName sub-command '$subcommand'."
exit 1

# "This Code is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . 
# Any additional contribution submitted for incorporation into or for distribution with this file shall be presumed
# subject to the same license."