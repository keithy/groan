#!/bin/bash

# The groan framework is implemented by a minimal set of scripts.
# All top-level "commands" are exactly the same code but with differing names.
# i.e. `rename-to-your-command-name` and `groan\groan` are identical.
#
# This "Command" script - Provides basic features and redirects `groan <cmd>` to `<cmd>.sub.sh`

# STRICT-MODE

# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob # make sure globs are empty arrays if nothing is found
set -o allexport

# FUNCTIONS

function identifyPlatform
{
    MACOSX=false
    WINDOWS=false
    UNIX=false

    system=$(uname)
    if [[  -d "/System/Library/Frameworks" ]] ; then
        MACOSX=true
    elif [ -d "/WINDOWS" ] ; then
        WINDOWS=true
    else
        UNIX=true
    fi
}

function readLocations
{
  commandFile="$1"
  commandDir=$(dirname "$commandFile")
  commandName=${commandFile##*/} # `basename $commandFile` 

  locations=("$commandDir/$commandName.commands") #default
  defaultSubcommand="_default" #default
  defaultDispatch="_dispatch.sh"

  #commandDir commandName globals used within <name>.locations.sh file

  locationsConfig="${commandDir}/${commandName}.locations.sh"
  $DEBUG && echo "Reading Locations: $locationsConfig"
  if [ -f "$locationsConfig" ]; then  
    source "$locationsConfig"
  else 
    $DEBUG && echo "^^ not found"
  fi
  return 0
}

function readConfig
{
    for configFile in ${configFileLocations[@]:-}
    do
        $DEBUG && echo "Looked for config in: $configFile"
        if [[ -f "$configFile" ]]; then
                $VERBOSE && echo "Reading configuration: $configFile"
                source "$configFile"
                break
        fi
    done
}

function readThemes
{
  bold=$''; dim=$''; bold=$''; reset=$''
  for themeFile in ${themePath[@]:-}
    do
        if [[ -f "$themeFile" ]]
        then
            $DEBUG && echo "Reading theme script: $themeFile"
            source "$themeFile"
        else
            $DEBUG && echo "Theme script not found: $themeFile"
        fi
    done

  return 0
}

# Args: "${args[@]:+${args[@]}}" # pattern needed when set -u is on bash<=4.1
 
function executeScript {

    scriptPath="$1"
    scriptDir="$2"
    scriptName="$3"
    scriptSubcommand="$4"

    if [ "$scriptSubcommand" != "$defaultSubcommand" ]; then
       breadcrumbs="${breadcrumbs} $scriptSubcommand"
    fi

    case ${scriptPath##*.} in
        sh)
            $DEBUG && echo "Running source: $scriptPath ${args[@]:+${args[@]}}"
            sourceScript "${args[@]:+${args[@]}}"
            return
        ;;
        exec)
            $DEBUG && echo "Running exec: $scriptPath ${args[@]:+${args[@]}}"
            exec "$scriptPath" "${args[@]:+${args[@]}}"
            return
        ;;
        *)
            $DEBUG && echo "Running metadata file: ${scriptPath/.sub.*/.meta.sh}"
            source "${scriptPath/.sub.*/.meta.sh}" ${args[@]:+${args[@]}}

            $SHOWHELP && executeHelp
            $METADATAONLY && return

            $DEBUG && echo "Running eval: $scriptPath ${args[@]:+${args[@]}}"				
            eval "$scriptPath" ${args[@]:+${args[@]}}
            return
        ;;
    esac
}

function sourceScript
{
    source "$scriptPath"
}

function executeHelp {
  printf "${bold}$description${reset}\n"
  printf "\n${bold}options:${reset}\n$commonOptions\n"
  printf "\n${bold}usage:${reset}\n$usage\n"
}

function checkMarkdownViewer {
    # Check for Markdown Viewer
    [[ -z $(which ${markdownViewerUtility%% *}) ]] && markdownViewerUtility="cat"
    $DEBUG && echo "Markdown viewer: $markdownViewerUtility"
}

# This function should be easy but bash begs to differ: ${args[@]:1}
function shiftArgsIntoNext {
    next=""
    params=()

    if [[ ${#args[@]} > 0 ]]; then
            for arg in "${args[@]}"
            do 
                    if [ -z "$next" ]; then
                            next="$arg"
                    else
                            params+=("$arg")
                    fi  
            done
    fi
    args=("${params[@]:+${params[@]}}")
}

# START

workingDir=$(pwd)

#find the $commandFile and importantly the $commandDir
commandFile="$(cd "${0%/*}" 2>/dev/null; echo "$PWD"/"${0##*/}")"
if [ -L "$commandFile" ]; then
  commandFile=`readlink -n $commandFile`
fi

# our contribution to help

commonOptions="common options:
--help    | -h | -?  Usage help for a command
--quiet   | -q       Quiet mode - say nothing
--verbose | -V       Verbose
--debug   | -d | -D  Debug - tell all
--dry-run            # default
--confirm            # not a dry run - perform action
--theme=light        # select an alternate colour theme"

#default flags

DEBUG=false
VERBOSE=false
LOUD=true
DRYRUN=true
CONFIRM=false
SHOWHELP=false     #exec command and only display the help metadata
METADATAONLY=false #exec command only as far as the help metadata
THEME=default

# Options processing pattern - search through the arguments for the command and flags

args=()
subcommand=""
for arg in "$@"
do
    case "$arg" in
      --debug | -d | -D)
            DEBUG=true
            VERBOSE=true
            LOUD=true
      ;;
      --help | -h | "-?")
            SHOWHELP=true
            METADATAONLY=true
      ;;
      --verbose | --v | -v | -V )
            DEBUG=false
            VERBOSE=true
            LOUD=true
       ;;
      --quiet | -q)
            LOUD=false
            DEBUG=false
            VERBOSE=false
      ;;
      --dry-run | -dry | --dry)
            DRYRUN=true
            CONFIRM=false
      ;;
      --confirm)
            DRYRUN=false
            CONFIRM=true
      ;;
      --theme=*)
            THEME=${arg##--theme=}
      ;;
      --*)
        args+=($arg)
      ;;
      *)
          if [[ "$subcommand" = "" ]]; then
             subcommand=$arg
          else
             args+=($arg)
          fi
      ;;
    esac
done
 
readLocations "$commandFile"

breadcrumbs="$commandName"
rootCommandFile="$commandFile"

readConfig
readThemes

$VERBOSE && echo "${bold}SCRIPT${reset}: $workingDir${dim}/${reset}${bold}$commandName${reset}"
 
# handle the default empty case
[ -z "$subcommand" ] && subcommand="$defaultSubcommand"

if $DEBUG; then
    echo "Sub-command: '$subcommand'"
fi

commandFileList=()
breadcrumbsList=()
for scriptDir in ${locations[@]} 
do
    dispatcher="$scriptDir/${defaultDispatch}"
    if [ -f "$dispatcher" ]; then
      source "$dispatcher"
      exit 0
    fi
done

$LOUD && echo "Dispatcher Not Found: ${defaultDispatch:-_dispatch.sh}.
exit 1

# "This Code is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php . 
# Any additional contribution submitted for incorporation into or for distribution with this file shall be presumed
# subject to the same license."