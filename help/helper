#!/usr/bin/env bash
#
# Never in the annals of software engineering was so much owed
# by so many to so few lines of code
#                                        -- Martin Fowler
#
##############################################################
# The groan framework is implemented by this one script.
#
# Shell sub-commands may be sourced for two purposes, 
# selected by the METADATAONLY flag.

##############################################################
# Default metadata - our contribution to help
#

options_common_vertical=\
"
--help    | -H | -?       usage help for a command
--list    | -L            commands list for a command
--quiet   | -Q            quiet mode - say nothing
--verbose | -V            verbose
--debug   | -D            debug - tell all (-GD)
--dry-run | -N
--confirm | -Y            not a dry run - perform action
--theme=light             select an alternate colour theme
--config=<choice> | -C=   select alternative config
"

options_common_horizontal=\
"
--help --quiet --verbose --debug
 -H     -Q      -V        -D
"

options_=""

##############################################################
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
# Unofficial "Bash Strict Mode"
#
set -euo pipefail
IFS=$'\n\t'
shopt -s nullglob # make sure globs are empty arrays if nothing is found
set -o allexport
NL=$'\n' # Just useful

##############################################################
# Everyfile in the toolset traditionally calls this function
#
function me() #BASH_SOURCE
{
  $GDEBUG && printf "\e[2m${1}\e[0m\n"
  my_path=$(realpath "${1}")
  my_file="${my_path##*/}"
  my_dir="${my_path%/*}"
}
 
##############################################################
# A standard means for platform differentiation
g_PLATFORM="${BASH_VERSINFO[5]}"

##############################################################
# Utility* to ensure that sudo is available
#
function g_needsSudo() {
    local prompt
    prompt=$(sudo -nv 2>&1)
    if [ $? -eq 0 ]; then
       $GDEBUG && g_echo "User has 'sudo' access."
    elif g_echo "$prompt" | grep -q '^sudo:'; then
       $GDEBUG && g_echo "User has sudo (password required)"
    else
       g_echo "this action requires 'sudo' access."
       exit 1
    fi
}

##############################################################
# Locations are the top level configuration for an executable
# they set where to find everything else, including config
# defaults are set here, and each executable may have a
# <exe>.conf (or perhaps a hidden .<exe>.conf)
#
# The first layer is "code defined" in the code below
# The second layer is "code defined" in the config dir, via the commands own name
# The third layer is "context defined", via the containing directory name
#   So - when the same code is used in a different context (containing directory),
#   values can be overridden using that context name.

function g_readConfig () # from conf files
{
  g_parseScriptPath "$1/$2"

  c_dir="$s_dir"
  c_file="$s_file"
  c_cmd="$s_cmd"
  c_dirname="${s_dir##*/}"
 
  local commands_folder="${3:-commands}"

  g_types=( cmd red wip obsolete )
  
  g_tmp=/tmp # TempDir for Linux ... or Windows
  #git bash has /tmp
  #[[ "$g_PLATFORM" == *msys* ]] && g_tmp="$HOME/AppData/Local/Temp"

  case $THEME in
      none | off | 0)
          bold=$''           # Style Bold
          dim=$''            # Style Dim
          italic=$''         # Style Italic
          underline=$'' # underline
          reversed=$''  # reversed
          reset=$''          # Reset
      ;;
      *)
          bold=$'\e[1m'      # Style Bold
          dim=$'\e[2m'       # Style Dim
          italic=$'\e[3m'    # Style Italic
          underline=$'\e[4m' # underline
          reversed=$'\e[7m'  # reversed
          reset=$'\e[0m'     # Reset
      ;;
  esac

  g_config_file_options=("user" "context" "global")
  g_config_file_locations=(
    "$HOME/.config/$g_dirname" # --user
    "${g_dir}/../config"       # --context
    "${g_dir}/config"  	       # --global # installed in the code/config dir
  )

  g_locations=(
	  "${c_dir}/${commands_folder}"                
	  "${c_dir}" 
	  "${c_dir}/help"                  
  )

  c_default="_default"

  #c_dir c_name globals used within <name>.conf file

  # If our context has a different name look for our configuration in these locations
  # [[ "$c_file" != "$c_dirname" ]] && \
  g_find_ "Locations1" "${c_file}.conf" "${c_dir}" "${c_dir}/config" && source "$g_found"
  
  # Look for our context defined configuration in these locations
  g_find "Locations2" "${c_dirname}.conf" && source "$g_found"
    
  # in preference to a hidden personal locations file
  #g_find_ "Locations" ".${c_file}.conf" "${c_dir}" && source "$g_found"

  # Obtain values from...
  if g_find_ Config "${CONFIG:-default}.conf" "${g_config_file_locations[@]}"
  then
    g_config="${g_found}"
    source "${g_config}"
  fi

  $DEFAULT && c_default=_xyz_default # manual override

  return 0
}

function g_readConfig_TopLevel () # parameters come from me() 
{
  g_path="${my_path}"
  g_dir="${my_dir}"
  g_dirname="${my_dir##*/}"
  [[ -z ${g_context+x} ]] && g_context="${g_dirname}"
  g_file="${my_file}"

  options_common_vertical+="${NL}--theme=neon             select an alternate colour theme"
  breadcrumbs="${g_file}"
}

##############################################################
# search g_config_file_locations set in g_readConfig
# find a <filename>
#

function g_find () #1) type_string #2) filename #) dirs to look
{
  g_find_ "$@" "${g_config_file_locations[@]}" && return 0 || return 1
}

function g_find_ () #1) type_string #2) filename #) dirs to look
{
  local dir file type="${1}" name="${2}" ; shift ; shift
	for dir in "$@"
    do
       g_found="${dir}/${name}"

       if [[ -f "${g_found}" ]]; then         
          $GDEBUG && g_echo "${type}< $(print_dir "$dir")/${name}"
          return 0
       fi
       $GDEBUG && g_echo "${type}? $(print_dir "$dir")/${name}"
    done
    return 1 # no file found
}

function print_dir ()
{
  local p_dir="${1/$PWD/\$PWD}"
  p_dir="${p_dir/${g_dir}/\$g_dir}"
  echo "${p_dir/$HOME/\$HOME}"
}

##############################################################
#
function define(){ IFS='\n' read -r -d '' ${1} || true; }

##############################################################
# on the tin
function u_parseYaml {
   local prefix=$2
   local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$'\034'
   sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p"  $1 |
   awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
         printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
   }'
}

##############################################################
# useful
u_join_into() {
    # $1 is return variable name
    # $2 is sep
    # $3... are the elements to join
    local retname=$1 sep=$2 ret=${3:-}
    shift 3 || shift $(($#))
    printf -v "$retname" "%s" "$ret${@/#/$sep}"
}

##############################################################
# useful
u_split_into() {
    # $1 is return array variable name
    # $2 is sep
    IFS="$2" read -r -a "$1" <<< "$3"
}

##############################################################
#
function g_executeScriptPath ()
{
  local bk=("${g_locations[@]}") 
  _g_executeScriptPath "$@"
  g_locations=("${bk[@]}")
}

function _g_executeScriptPath ()
{  
  g_parseScriptPath "$1"

  # When set -u is enabled bash<=4.1, this pattern
  # is needed: "${args[@]:+${args[@]}}"

  $METADATAONLY && local status="Metadata" || local status="Running"

  case "${s_ext}" in
    conf)
        $GDEBUG && g_echo "$status< $s_path"
        g_pathScriptMappingArgs "$s_path" "${args[@]:+${args[@]}}" && $METADATAONLY && return 0

        for script in "${s_dir}/${s_file%.*.conf}" "${s_dir}/${s_file%.*.conf}".*
        do
          if [[ "$script" != "$s_path" ]] && [[ -f "$script" ]]; then
            g_executeScriptPath "$script" "${args[@]:+${args[@]}}"
              
            $SHOWHELP && g_displayHelp && exit  # moved to post dispatch
            $METADATAONLY && return 0            
            exit
          fi
        done
    ;;
    sh)
        $GDEBUG && g_echo "$status source> $(print_dir "$s_path") ${args[@]:+${args[@]}}"        
  
        $XDEBUG && set -x
        g_pathScriptMappingArgs "$s_path" "${args[@]:+${args[@]}}"
        $XDEBUG && set +x
    ;;
    exec)
        $GDEBUG && g_echo "$status exec> $(print_dir "$s_path") ${args[@]:+${args[@]}}"
        exec "$s_path" "${args[@]:+${args[@]}}"
    ;;
    ps1)
        $GDEBUG && g_echo "$status exec> $(print_dir "$s_path") ${args[@]:+${args[@]}}"
        exec powershell.exe -NoProfile -ExecutionPolicy Bypass -File "$s_path" "${args[@]:+${args[@]}}"
    ;; 
    su)
        $GDEBUG && g_echo "$status sudo> $(print_dir "$s_path") ${args[@]:+${args[@]}}"
        sudo "$s_path" "${args[@]:+${args[@]}}"
    ;;
    *)
        $GDEBUG && g_echo "$status eval> $(print_dir "$s_path") ${args[@]:+${args[@]}}"
        $XDEBUG && set -x
        eval "$s_path" "${args[@]:+${args[@]}}"
        $XDEBUG && set +x
        exit 0
    ;;
  esac
  return 0 # needed due to use of &&
}

# Acts as a destructor to clear down variables that would otherwise
# have knock on effects when collecting metatdata in command lists.
function _g_unsetMetadata
{
  unset wip
  unset description
}

# other commands can redefine this to add additional fields to unset
function g_unsetMetadata
{
  _g_unsetMetadata
}

##############################################################
# Sourcing a script is done via this function
# so that args are automatically mapped in to $@
function g_pathScriptMappingArgs
{
	local source="$1"
	shift
  source "$source"
}

##############################################################
#
# If description is not defined - no help is displayed.
#
# Help is in three parts: description, options, usage
# Each has a main and supplementary
#   - $description and $description_
#   - $options     and $options_
#   - $usage       and $usage_
#
# Description - is displayed with the first line in bold
# Options - section titled in bold 'options:'
# Usage   - section titled in bold 'usage:'
# 
options=""; options_=""; usage=""; usage_=""

function g_displayHelp {

  print_description

  print_options
  
  print_usage

  return 0
}

function _print_command_description()
{
  printf "${bold}${c_description:-}${reset}"
}

function print_command_description()
{
  _print_command_description
  printf "${c_description+\n\n}" # if the c_description is defined
}

function _print_description()
{
  [[ -z ${description+x} ]] && g_echo "command description is missing" && return 1

  local desc="$description${NL}"

  printf "${bold}"
  _print_description_first_line
  printf "${reset}"
  printf "\n${reset}${desc#*$'\n'}"
}

function print_description()
{
  _print_description
  printf "${description+\n}"
}

function _print_description_first_line()
{
    for line in $(printf "${description}")
    do
      printf "$line"
      return 0
    done
}

function print_command_list_description()
{
  _print_description_first_line
}

function _print_options ()
{
  if [[ -z "${options}" ]]; then
    printf "${bold}options:${reset}%s" "${options_common_vertical}"
  else
    printf "${bold}options:${reset}%s%s" "${options_common_horizontal}" "$options"  
  fi
  [[ -n ${options_+x} ]] && echo "${options_#*$'\n'}"

  return 0
}

function print_options ()
{
  _print_options
}

function _print_usage()
{
  printf "${bold}usage:${reset}${usage}"
}

function print_usage()
{
  _print_usage
  [[ -n ${usage_+x} ]] && printf "${usage_}"
  return 0
}

function print_kv()
{
  $LOUD && echo "${bold}${1}:${reset} ${2:-}${2:+ }${dim}${3:-}${reset}" || echo "${2:-}"
  return 0 # needed
}

function g_debug_kv()
{
  $GDEBUG && print_kv "${1}" "${!1:-}${2:-}"
  return 0 #(neded)
}

function g_echo() {
  >&2 echo "$@" # or { printf "%s\n" "$*" >&2; }
}

# loads a help variable
# e.g. g_help options_ "--status" "ping the server"

function g_help()
{
  [[ -n ${3+x} ]] \
   && printf -v "$1" "%s%-27s%s\n" "${!1}" "$2" "$3" \
   || printf -v "$1" "%s%s\n" "${!1}" "$2"
  return 0
}

##############################################################

g_option_vars=()
function g_declare_options ()
{
  g_option_vars+=( "$@" )
  for var in "$@"; do
    declare -g "$var"="false"
  done
}

function g_bashrc_install ()
{
	local tag="##:${1}:##" #1) tag
  local dest="$2"  #2) dest file - "$HOME/.bashrc"
  local line="$3"  #3) line to add
  local wipfile="${g_tmp}/${2////-}"

  # backup
	touch "$dest" 
	cp "$dest" "$wipfile" || true

	$GDEBUG && g_echo "Before:" && cat "$wipfile"

	# clean one liner
	{ \rm "$wipfile" && grep -v "$tag" > "$wipfile" ; } < "$wipfile" || true

	$GDEBUG && g_echo "Cleaned:" && cat "$wipfile" && echo

  # append
	touch "$wipfile"
	printf "%s %s\n" "$line" "$tag" >> "$wipfile"

  $VERBOSE && g_echo "${dim}New bashrc:${reset}" && cat "$wipfile" || true
	$CONFIRM && cp "$wipfile" "$dest" || g_echo "DRY-RUN --confirm to apply"
}

##############################################################
#
function g_onEXIT_ ()
{
  printf "on EXIT functions: "
  declare -F | awk 'sub(/.*g_onEXIT_/,"")' | xargs printf "%s, "  
}

function g_onEXIT_where ()
{
    env | grep -E "^my_"
}

function g_onEXIT_options ()
{
  local vars
  g_join_into vars '|' "${g_option_vars[@]}"
  env | grep -E "^($vars)"
}

function g_onEXIT_groan ()
{
  env | grep -E "^[a-z]_"
}

function g_onEXIT_env ()
{
    # fix unhelpful colour changes
    env | sed "s/$/${reset}/"
}

function g_onEXIT_var ()
{
    print_kv "$show_me_variable" "${!show_me_variable}"
}

##############################################################
#
function g_view { # Check for Markdown Viewer other wise cat
    if [[ -z $(command -v "${g_markdown_viewer%% *}") ]]; then
	    $GDEBUG && g_echo "Markdown viewer: $g_markdown_viewer"
    
		"${g_markdown_viewer%% *}" "${g_markdown_viewer#* }" "$1"
    else
    	cat "$1"
    fi  
}

##############################################################
# Should simply be ${args[@]:1} but bash begs to differ:
#
function g_shiftArgsInto_g_next ()
{
    g_next=""
    local arg params=()
    if [[ "${#args[@]}" -gt 0  ]]; then
      for arg in "${args[@]}"
      do 
        if [[ -z "$g_next" ]]; then
          if [[ "$arg" == '--' ]]; then
            g_next="$c_default"
          elif [[ "${arg:0:1}" != "-" ]]; then
            g_next="$arg"
          fi                           
        else
          params+=("$arg")
        fi  
      done
    fi
    args=("${params[@]:+${params[@]}}")
    [[ -n "${g_next}" ]]
}

function g_parseScriptPath ()
{
  s_path="$1"
  s_file="${s_path##*/}"          # path, removing upto last '/'
  s_dir="${s_path%/*}"            # path, removing after last '/'
  s_cmd="${s_file%%.*}"           # name, up to first '.'      
  s_ext="${s_file##*.}"           # name, remove up to last '.'    
  s_base="${s_file%.*}"           # name, keep up to last '.'

  s_rest="${s_base#*${s_type:-}.}"  # base, remove up to first type
}

# Recursively scan the g_nexts for those that call the g_dispatcher of a contained command
# g_findCommands populates two arrays
# c_file_list= each element is a sub-command file (e.g. helper)
# breadcrumbs_list= each element is a list of c_cmds that reaches the above command

function g_findCommands()
{
  local c_dir="$1" c_file="$2"

  c_file="$c_dir/$c_file"
  c_file_list+=("$c_file")

  local crumbs="${3:-}"
  crumbs_list+=("$crumbs")
  
  $GDEBUG && printf "CMD: %s %s\n" "${crumbs}" "${c_file}"
  $GDEBUG && g_echo "Command: ${dim}${c_dir}${reset}/${bold}${c_file}${reset} ${c_cmd} ${args[@]:+${args[@]}}" 

  local s_dir
  local s_path

  g_readConfig "$c_dir" "$c_file"

  for s_type in "${g_types[@]}"
  do
    for s_dir in "${g_locations[@]}"
    do
      for s_path in "$s_dir"/*.${s_type}.*.sub.*
      do
        g_parseScriptPath "$s_path"

        if [ -n "$s_cmd" ]; then
          #if ! [[ "$s_dest_subcmd_name" == *.${s_type}.* ]]; then #this c_cmd invokes a g_dispatcher
            if $s_isDispatcher; then
              crumbs="$2 $s_cmd"
              g_findCommands "$s_dir" "$s_file" "$crumbs"
            fi
        fi
      done
    done
  done
}

function g_aliasDispatch ()
{
  s_alias="$s_cmd"
  g_debug_kv s_alias
  g_dispatch "$@"
}

function g_dispatch ()
{
  local DEFAULT=false
  [[ -z ${1+x} ]] && DEFAULT=true

  s_cmd="${1:-$c_default}"

  g_debug_kv s_dir
  g_debug_kv s_name
  g_debug_kv s_cmd

  local found=() found_cmd=() found_type=()
  for s_type in "${g_types[@]}"
  do
    local target="${s_cmd}*.${s_type}.*"
    local exact="${s_cmd}.${s_type}.*"

    for s_dir in "${g_locations[@]}"
    do
      for s_path in "$s_dir"/$exact
      do
        target="$exact" # upgrade the target to prioritize the exact match
      done
    done

    for s_dir in "${g_locations[@]}"
    do
      $GDEBUG && g_echo "Scanning for $target in: $(print_dir "$s_dir")"

      for s_path in "$s_dir"/$target
      do
        g_parseScriptPath "$s_path"
        found+=("$s_path")
        found_cmd+=("$s_cmd")
        found_type+=("$s_type")
        $GDEBUG && g_echo "Found #${#found[@]} : $s_cmd : $(print_dir "$s_path")"       
      done
    done
  done

  if [ ${#found[@]} -gt 1 ]; then
    $LOUD && echo "Multiple matches found for '${g_next}' (${found_cmd[@]})"
    exit 1
  fi

  if [ ${#found[@]} -eq 1 ]; then # one script matches
    s_type="${found_type[0]}"
    g_parseScriptPath "$s_path"
    [[ "$s_cmd" != _* ]] && [[ -z "${s_alias:-}" ]] && breadcrumbs="$breadcrumbs $s_cmd"

    g_unsetMetadata
    g_executeScriptPath "$s_path" "${args[@]:+${args[@]}}"

    $SHOWHELP && g_displayHelp && exit 0
    $METADATAONLY && return 0 || exit 0
  fi

  # if we were trying the default command and did not find it"
  $DEFAULT && return 1

  $METADATAONLY && return 0
  
  # otherwise it broke`
  $LOUD && g_echo "Not Found: $breadcrumbs ${bold}${s_cmd}${reset}"
  exit 1
}

function g_listCmds()
{
  g_parseScriptPath "$1"
	local crumbs="$2"

 	g_readConfig "${s_dir}" "${s_file}"

	# Display the default sub-command at the top of  the list (without its breadcrumb)

	local subs=()

  for s_type in "${g_types[@]}"
  do
    for s_dir in "${g_locations[@]}"
    do
      for s_path in "$s_dir/${c_default}.${s_type}."*
      do
        subs+=("$s_path")
      done
    done
  done

  for s_path in "${subs[@]}"
  do
    g_parseScriptPath "$s_path"

    g_unsetMetadata
    METADATAONLY=true g_executeScriptPath "$s_path"  

    printf "%-${bw}s" "$crumbs"
    print_command_list_description
    printf "\n"
  done

  for s_type in "${g_types[@]}"
  do

    for s_dir in "${g_locations[@]}" ; do

      #Display the c_cmds (with breadcrumb)
      for s_path in "$s_dir"/[^_]*.${s_type}.*
      do
        g_parseScriptPath "$s_path"
    
        # commented out this if clause so as to include display of commands that go a level deeper
        # these would not normally be included in the full recursive list of commands
    
        #if [[ -n "$s_cmd" ]] && [[ "$s_dest_subcmd_name" == *.${s_type}.* ]]; then
  
        if $VERBOSE || [[ "$s_type" == "${g_types[0]}" ]]; then

          crumbs="$2 $s_cmd"

          g_unsetMetadata
          METADATAONLY=true g_executeScriptPath "$s_path"

          printf "%-${bw}s" "$crumbs"

          print_command_list_description

          [[ "$s_type" != "${g_types[0]}" ]] && printf " ($s_type)"

          echo

        fi

      done
    done
  done
}

function g_builtin ()
{
  description="list $c_file commands"

  # since help doesn't exec anything many common options don't apply
  options_common_vertical=\
"
--theme=0                        alternate theme
--install                        install as bash alias
--install=<name>                 install as bash alias <name>
--install=<name> --config=<alt>  install with config <alt>
--temp                           print the temp directory
--which                          print the code directory
"

  usage=\
"
$breadcrumbs                        list commands
$breadcrumbs --install              install as bash alias
$breadcrumbs --install=dtt -C=dtt   install as bash alias with config
"

  $METADATAONLY && return 0

  g_declare_options LIST SHOW_TEMP SHOW_EXE INSTALL

  LIST=true
  install_as=""

  for arg in "${args[@]:+${args[@]}}"
  do
    LIST=false
    case "$arg" in
      --install=*)
        INSTALL=true
        install_as=${arg#--install=}
      ;;
      --install)
        INSTALL=true
      ;;
      --temp)
        SHOW_TEMP=true
      ;;
      --which)
        SHOW_EXE=true
      ;;
    esac
  done

  if $SHOW_TEMP; then
    echo "$g_tmp"
    exit
  fi 

  if $SHOW_EXE; then
    echo "$g_path"
    exit
  fi 

  if $INSTALL; then

    with_config=""
    if [[ -n ${CONFIG+x} ]]; then
      with_config=" -C=$CONFIG"
    fi

    if [[ -n "${install_as}" ]]; then
        g_bashrc_install "${install_as}" "$HOME/.bashrc" "alias ${install_as}='${g_path} ==g_file=${install_as}$with_config'"
    else
        g_bashrc_install "$g_file" "$HOME/.bashrc" "alias ${g_file}='${g_path}$with_config'"
    fi

    $CONFIRM && echo "To use the installed feature - start a new bash"
    :
  fi

  $LIST && g_listCommands

  exit 0
}

function g_listCommands ()
{
  # Display Command Description

  print_command_description

  # Display List

  bw=${breadcrumbs_width:-25}
  c_file_list=()
  crumbs_list=()

  # start search at this level, not the top level
  g_findCommands "$c_dir" "$c_file" "$breadcrumbs" false
  
  if $GDEBUG; then # print out results of recursive search
    echo
    for i in "${!c_file_list[@]}"; do    
        printf "(%d) %-30s" "$i" "${crumbs_list[i]}"
        echo "${c_file_list[i]}"
    done
    echo
  fi

  # only display our direct c_cmds (no need to loop)
  i=0
  #for i in "${!c_file_list[@]}"; do
    displayName="${c_file_list[i]##*/}"
    #echo "${bold}${displayName/-/ } commands:${reset}"
    #echo "${bold}${g_dir##*/} commands:${reset}"
    echo "${bold}${g_context} ${displayName} commands:${reset}"
    
    g_listCmds "${c_file_list[i]}" "${crumbs_list[i]}"
    
    echo
  #done
}
##############################################################
# Parsing options the groan way - first initialize all flags
#
g_declare_options METADATAONLY SHOWHELP CONFIRM DRYRUN THEME

DRYRUN=true
THEME="${THEME:-default}"

##############################################################
# Debug verbosity levels
# DEBUG  -D  User level Debug (for non-groan code)
# DDEBUG -DD Developer level "Deep" Debug (for non-groan code)
# GDEBUG -GD Debug (for groan code)
# XDEBUG -XD Bash shell debugging using set -x

g_declare_options XDEBUG DDEBUG DEBUG GDEBUG VERBOSE ENVIRONMENT LOUD DEFAULT
LOUD=true

##############################################################
# Top level - universal options processing pattern
#
args=()
for arg in "$@"
do
    shift # needed for the -- option
    case "$arg" in
      -- )
        args+=( '--' "$@" )
        break
      ;;
      ==*=*)
        arg="${arg#==}"
        declare "${arg%%=*}"="${arg#*=}"
      ;;
      ==*)
        show_me_variable="${arg#==}"
      ;;
      -DD|--ddebug|--deep-debug) 
        DDEBUG=true
      ;;
      -GD|--groan-debug)
        GDEBUG=true
        DEBUG=true
        VERBOSE=true
        LOUD=true
      ;;
      -XD|--bash-debug)
        XDEBUG=true
      ;;
      -D | --debug)
        DEBUG=true
        VERBOSE=true
        LOUD=true
      ;;
      --help | -H | "-?")
        SHOWHELP=true
        METADATAONLY=true
      ;;
      --default | -L )
        DEFAULT=true
      ;;
      --verbose | -V )
        GDEBUG=false
        DEBUG=false
        VERBOSE=true
        LOUD=true
      ;;
      -EXIT=* )
        trap "g_onEXIT_${arg#-EXIT=}" EXIT
      ;;
      --quiet | -Q)
        LOUD=false
        GDEBUG=false
        VERBOSE=false
      ;;
      --dry-run | -N)
        DRYRUN=true
        CONFIRM=false
      ;;
      --confirm| -Y)
        DRYRUN=false
        CONFIRM=true
      ;;
      --config=*)
        CONFIG="${arg##--config=}"
      ;;
      -C=*)
        CONFIG="${arg##-C=}"
      ;;
      --theme=*)
        THEME="${arg##--theme=}"
      ;;
      *)
        args+=("$arg")
      ;;
    esac
done
 
##############################################################
# START READING CONFIGURATION
#

me "${BASH_SOURCE}" # eat our own dog food

g_readConfig_TopLevel
g_readConfig "$my_dir" "$my_file"

# $DEFAULT && c_default=_xyz_default # manual override

g_shiftArgsInto_g_next && g_dispatch "$g_next" || g_dispatch || g_builtin

$SHOWHELP &&  g_displayHelp
 
return 0

:
# "This Code is distributed subject to the MIT License, as in http://www.opensource.org/licenses/mit-license.php 
# Any additional contribution submitted for incorporation into or for distribution with this file shall be presumed
# subject to the same license."
